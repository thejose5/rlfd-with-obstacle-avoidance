import pickle as pkl
from itertools import count

from utils import *
from motion_planner import *
from kmp import *

def get_colliding_section(pred_path, via_pts):
    """
    Returns the section of the path that is colliding with an obstacle
    :param pred_path: predicted path
    :param via_pts: the list of via points generated by motion planner
    :return: colliding_section{'end_pts': The first and last colliding point
                                'last_via_pt_index': The index of the last via pt before collision
    """
    colliding_section = {'end_pts':[], 'last_via_pt_index':0}
    for i in range(1,len(pred_path)):
        if not isCollisionFree(pred_path[i-1], pred_path[i], res=10):
            colliding_section['end_pts'].append(pred_path[i - 1])
            while not isCollisionFree(pred_path[i-1], pred_path[i], res=10):
                i = i+1
            colliding_section['end_pts'].append(pred_path[i - 1])
            break
        else:
            for ind, via_pt in enumerate(via_pts):
                if euclidean_distance(via_pt, pred_path[i]) < 1:
                    colliding_section['last_via_pt_index'] = ind
                    break
        # elif pred_path[i] in via_pts:
        #     colliding_section['last_via_pt_index'] = via_pts.index(pred_path[i])

    return colliding_section



def add_via_pt(colliding_section, via_pts):
    """
    Given the colliding section, generates a via point that avoids the obstacle
    :param colliding_section:
    :param via_pts:
    :return: updated via_pts
    """
    end_pts = colliding_section['end_pts']
    m = (end_pts[1][1] - end_pts[0][1]) / (end_pts[1][0] - end_pts[0][0])
    m = -1/m
    mid_pt = [(end_pts[0][0] + end_pts[1][0])/2, (end_pts[0][1] + end_pts[1][1])/2]
    for i in count():
        mul = (-1)**i * 0.1 # Multiplier
        x = mid_pt[0] + mul*(i+1)
        y = mid_pt[1] + m*mul*(i+1)
        if isStateValid((x,y)):
            via_pts.insert(colliding_section['last_via_pt_index']+1,[x,y])
            return via_pts
        if i>2000:
            raise Exception("add_via_pt can't find a collision free point")


# Generate Map: obstacles, start pt, end pt
env_map = Map()

# Send map to motion planner and return via points
via_pts = plan_motion(env_map)

draw_everything(env_map, None, via_pts)
exit()

# Scale down via pts and kmp.predict
scale_factor = 100
via_pts_scaled_d = [[x / scale_factor, y / scale_factor] for [x, y] in via_pts]

print("Final Via Points: ", via_pts)
filehandler = open("../pickled_objects/kmp.obj", 'rb')
kmp = pkl.load(filehandler)
pred_traj = kmp.prediction(via_pts_scaled_d)
pred_path = extractPath(pred_traj)

# Scale up predicted path
pred_path_scaled_u = [[x*scale_factor, y*scale_factor] for [x,y,_,_] in pred_path]
print("Final Trajectory: ", pred_path_scaled_u)

# Draw everything
draw_everything(env_map, pred_path_scaled_u, via_pts)

# Check if predicted path is collision free and add via points until it is
colliding_section = get_colliding_section(pred_path_scaled_u, via_pts)

while(colliding_section['end_pts'] != []):
    print("Colliding Section1", colliding_section['end_pts'])
    print("Colliding Section2", colliding_section['last_via_pt_index'])
    via_pts = add_via_pt(colliding_section, via_pts)
    via_pts_scaled_d = [[x / scale_factor, y / scale_factor] for [x, y] in via_pts]
    pred_traj = kmp.prediction(via_pts_scaled_d)
    pred_path = extractPath(pred_traj)
    pred_path_scaled_u = [[x * scale_factor, y * scale_factor] for [x, y, _, _] in pred_path]
    draw_everything(env_map, pred_path_scaled_u, via_pts)
    colliding_section = get_colliding_section(pred_path_scaled_u, via_pts)

print("No Collisions!")
# Draw everything
# draw_everything(env_map, pred_path_scaled_u, via_pts)
exit()