import math
from os.path import abspath, dirname, join
import sys

import pickle as pkl
import numpy as np

sys.path.insert(0, join(dirname(dirname(abspath(__file__))), 'py-bindings'))
from ompl import base as ob
from ompl import geometric as og
from utils import *

ENV_MAP = Map()

def euclidean_distance(pt1, pt2):
    return np.sqrt((pt1[0] - pt2[0])**2 + (pt1[1] - pt2[1])**2)

def isCollisionFree(pt1, pt2, res=1000):
    """
    Checks a straight line between pt1 and pt2 is collision free
    :param res: Resolution. The number of points to be generated and checked between pt1 and pt2.
    :return: true/false
    """
    if pt2[0] != pt1[0]:
        m = (pt2[1] - pt1[1]) / (pt2[0] - pt1[0])
        c = pt1[1] - m * pt1[0]
        X = np.linspace(pt1[0], pt2[0], res)
        Y = m * X + c
        for pt in zip(X, Y):
            if not isStateValid(pt, False):
                return False

    else:
        Y = np.linspace(pt1[1], pt2[1], res)
        X = 0 * Y + pt1[0]
        for pt in zip(X, Y):
            if not isStateValid(pt, False):
                return False

    return True


def optimizePath(path):
    """
    Returns a path with minimum number of points
    :param path: Path generated by OMPL
    :return: Optimized path
    """
    if len(path) <= 1:
        return []
    if len(path) == 2:
        return path

    l = 0
    r = int(len(path)) - 1
    left_checked_boundary = l  # Closest known collision free point
    right_checked_boundary = r  # Closest known not collision free point
    while (right_checked_boundary - left_checked_boundary) > 1:
        if isCollisionFree(path[l], path[r]):
            left_checked_boundary = r
        else:
            right_checked_boundary = r
        r = int((left_checked_boundary + right_checked_boundary) / 2)

    # while(not isCollisionFree(path[l],path[r])):
    #     r = int(r/2)
    #     print("r =",r)
    return [path[l], path[left_checked_boundary]] + optimizePath(path[left_checked_boundary:])[1:]


def isStateValid(state, forOMPL=True):
    # env_map = pkl.load(open("../pickled_objects/map","rb"))
    global ENV_MAP
    multiplier = 0.9 if forOMPL else 1
    # Multiplier increases the size of obstacles so that BITstar plans a path with some buffer space
    # TODO: Fix this multiplier. Make what it means more obvious.

    # Check circles
    for circle in ENV_MAP.circles:
        if euclidean_distance(state, (circle[0], circle[1])) <= circle[2]/multiplier:
            return False

    # Check rectangles
    for rectangle in ENV_MAP.rectangles:
        if ((rectangle[0]*multiplier <= state[0] <= (rectangle[0]*multiplier + rectangle[2]/(multiplier**2)) and
             rectangle[1]*multiplier <= state[1] <= (rectangle[1]*multiplier + rectangle[3]/(multiplier**2)))):
            # Need to do multiplier**2 because just multiplier doesn't provide enough buffer
            return False

    return True



def planBITstar(q_st, q_g, res, ):
    # create an SE2 state space
    space = ob.RealVectorStateSpace(2)

    # set lower and upper bounds
    bounds = ob.RealVectorBounds(2)
    bounds.setLow(0)
    bounds.setHigh(res)
    space.setBounds(bounds)

    # construct an instance of space information from this state space
    si = ob.SpaceInformation(space)

    # set state validity checking for this space
    si.setStateValidityChecker(ob.StateValidityCheckerFn(isStateValid))

    # create a random start state
    start = ob.State(space)
    start[0] = q_st[0]
    start[1] = q_st[1]

    # create a random goal state
    goal = ob.State(space)
    goal[0] = q_g[0]
    goal[1] = q_g[1]

    # create a problem instance
    pdef = ob.ProblemDefinition(si)

    # set the start and goal states
    pdef.setStartAndGoalStates(start, goal)

    # create a planner for the defined space
    planner = og.BITstar(si)

    # set the problem we are trying to solve for the planner
    planner.setProblemDefinition(pdef)

    # perform setup steps for the planner
    planner.setup()

    # print the settings for this space
    # print(si.settings())

    # print the problem settings
    # print(pdef)

    # attempt to solve the problem within one second of planning time
    solved = planner.solve(1.0)

    if solved:
        # get the goal representation from the problem definition (not the same as the goal state)
        # and inquire about the found path
        path = pdef.getSolutionPath()
        print("Found solution:\n")
        path_arr = []
        print(path.getStateCount())
        for i in range(path.getStateCount()):
            path_arr.append([])
            path_arr[i].append(path.getState(i)[0])
            path_arr[i].append(path.getState(i)[1])
        return path_arr
    else:
        print("No solution found")
        return []


def plan_motion(env_map):
    # filehandler = open("../pickled_objects/map", 'w')
    # pkl.dump(env_map, filehandler)
    global ENV_MAP
    ENV_MAP = env_map
    path = [env_map.motion_targets[0]]
    for i in range(1, len(env_map.motion_targets)):
        subpath = planBITstar(env_map.motion_targets[i-1], env_map.motion_targets[i], env_map.res)
        if not subpath:
            print("No path possible")
            exit()
        print("SUBPATH",i,": ", subpath)
        subpath = optimizePath(subpath)
        path = path + subpath[1:]
    print(path)

    return path
